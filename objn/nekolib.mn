#import "../objn/nekolib.hn"

{
var utf8_buf_alloc = $loader.loadprim("std@utf8_buf_alloc", 1),
	utf8_buf_add = $loader.loadprim("std@utf8_buf_add", 2),
	utf8_buf_content = $loader.loadprim("std@utf8_buf_content", 1),
	utf8_buf_length = $loader.loadprim("std@utf8_buf_length", 1),
	utf8_buf_size = $loader.loadprim("std@utf8_buf_size", 1),
	utf8_validate = $loader.loadprim("std@utf8_validate", 1),
	utf8_length = $loader.loadprim("std@utf8_length", 1),
	utf8_get = $loader.loadprim("std@utf8_get", 2),
	utf8_sub = $loader.loadprim("std@utf8_sub", 3),
	utf8_iter = $loader.loadprim("std@utf8_iter", 2),
	utf8_compare = $loader.loadprim("std@utf8_compare", 2)

@implementation NL_UTF8
	+ buf_alloc:size {
		return utf8_buf_alloc(size)
	}
	+ buf_add:buf char:char {
		utf8_buf_add(buf, char)
	}
	+ buf_content:buf {
		return utf8_buf_content(buf)
	}
	+ buf_length:buf {
		return utf8_buf_length(buf)
	}
	+ buf_size:buf {
		return utf8_buf_size(buf)
	}
	+ validate:str {
		return utf8_validate(str)
	}
	+ length:str {
		return utf8_length(str)
	}
	+ sub:str pos:pos len:len {
		return utf8_sub(str, pos, len)
	}
	+ get:str index:index {
		return utf8_get(str, index)
	}
	+ iter:str with:func {
		utf8_iter(str, func)
	}
	+ compare:str1 with:str2 {
		return utf8_compare(str1, str2)
	}
@end
}

{
var unicode_lower = $loader.loadprim("std@unicode_lower", 2),
	unicode_upper = $loader.loadprim("std@unicode_upper", 2)

@implementation NL_unicode
	+ lower:str enc:enc {
		return unicode_lower(str, enc)
	}
	+ upper:str enc:enc {
		return unicode_upper(str, enc)
	}
@end
}

{
var get_env = $loader.loadprim("std@get_env", 1),
	put_env = $loader.loadprim("std@put_env", 2),
	
	set_time_locale = $loader.loadprim("std@set_time_locale", 1),
	
	get_cwd = $loader.loadprim("std@get_cwd", 0),
	set_cwd = $loader.loadprim("std@set_cwd", 1),
	
	sys_sleep = $loader.loadprim("std@sys_sleep", 1),
	
	sys_command = $loader.loadprim("std@sys_command", 1),
	sys_exit = $loader.loadprim("std@sys_exit", 1),
	
	sys_string = $loader.loadprim("std@sys_string", 0),
	sys_is64 = $loader.loadprim("std@sys_is64", 0),
	sys_stat = $loader.loadprim("std@sys_stat", 1),
	
	sys_time = $loader.loadprim("std@sys_time", 0),
	sys_cpu_time = $loader.loadprim("std@sys_cpu_time", 0),
	sys_thread_cpu_time = $loader.loadprim("std@sys_thread_cpu_time", 0),
	
	sys_env = $loader.loadprim("std@sys_env", 0),
	
	sys_create_dir = $loader.loadprim("std@sys_create_dir", 2),
	sys_remove_dir = $loader.loadprim("std@sys_remove_dir", 1),
	sys_read_dir = $loader.loadprim("std@sys_read_dir", 1),
	
	sys_exists = $loader.loadprim("std@sys_exists", 1),
	sys_rename = $loader.loadprim("std@sys_rename", 2),
	sys_file_type = $loader.loadprim("std@sys_file_type", 1),
	
	sys_exe_path = $loader.loadprim("std@sys_exe_path", 0),
	
	sys_getch = $loader.loadprim("std@sys_getch", 1),
	
	sys_get_pid = $loader.loadprim("std@sys_get_pid", 0),
	
	win_env_changed = $loader.loadprim("std@win_env_changed", 0)
	

@implementation NL_sys
	+ get_env:name {
		return get_env($string(name))
	}
	+ set_env:name to:value {
		put_env(name, value)
	}
	
	+ set_time_locale:value {
		set_time_locale(value)
	}
	
	+ get_cwd {
		return get_cwd()
	}
	+ set_cwd:cwd {
		set_cwd(cwd)
	}
	
	+ sleep:time {
		sys_sleep(time)
	}
	
	+ command:cmd {
		return sys_command(cmd)
	}
	+ exit:code {
		sys_exit(code)
	}
	
	+ string {
		return sys_string()
	}
	+ is64 {
		return sys_is64()
	}
	+ stat:file {
		return sys_stat(file)
	}
	
	+ time {
		return sys_time()
	}
	+ cpu_time {
		return sys_cpu_time()
	}
	+ thread_cpu_time {
		return sys_thread_cpu_time()
	}
	
	+ env {
		return sys_env()
	}
	
	+ create_dir:path mode:mode {
		sys_create_dir(path, mode)
	}
	+ remove_dir:path {
		sys_remove_dir(path)
	}
	+ read_dir:path {
		return sys_read_dir(path)
	}
	
	+ exists:item {
		return sys_exists(item)
	}
	+ rename:item to:name {
		sys_rename(item, name)
	}
	+ file_type:path {
		return sys_file_type(path)
	}
	
	+ exe_path {
		return sys_exe_path()
	}
	
	+ getch:echo {
		return sys_getch(echo)
	}
	
	+ get_pid {
		return sys_get_pid()
	}
	
	+ win_env_changed {
		return win_env_changed()
	}
@end
}

{
var file_full_path = $loader.loadprim("std@file_full_path", 1),
	file_contents = $loader.loadprim("std@file_contents", 1),
	
	file_read_char = $loader.loadprim("std@file_read_char", 1),
	file_stdin = $loader.loadprim("std@file_stdin", 0)

@implementation NL_file
	+ full_path:path {
		return file_full_path(path)
	}
	+ contents:filename {
		return file_contents(filename)
	}
	
	+ read_char:file_obj {
		return file_read_char(file_obj)
	}
	
	+ stdin {
		return file_stdin()
	}
@end
}

{
var process_run = $loader.loadprim("std@process_run", 2),
	process_stdout_read = $loader.loadprim("std@process_stdout_read", 4),
	process_stderr_read = $loader.loadprim("std@process_stderr_read", 4),
	process_stdin_write = $loader.loadprim("std@process_stdin_write", 4),
	process_stdin_close = $loader.loadprim("std@process_stdin_close", 1),
	process_exit = $loader.loadprim("std@process_exit", 1),
	process_pid = $loader.loadprim("std@process_pid", 1),
	process_close = $loader.loadprim("std@process_close", 1),
	process_kill = $loader.loadprim("std@process_kill", 1)

@implementation NL_process
	+ run:cmd args:args {
		return process_run(cmd, args)
	}
	
	// idk how this actually works
	+ stdout_read:proc buf:str pos:pos len:len {
		return process_stdout_read(proc, str, pos, len)
	}
	+ stderr_read:proc buf:str pos:pos len:len {
		return process_stderr_read(proc, str, pos, len)
	}
	
	+ stdin_write:proc buf:str pos:pos len:len {
		return process_stdin_write(proc, str, pos, len)
	}
	+ stdin_close:proc {
		process_stdin_close(proc)
	}
	
	+ exit:proc {
		return process_exit(proc)
	}
	+ pid:proc {
		return process_pid(proc)
	}
	+ close:proc {
		process_close(proc)
	}
	+ kill:proc {
		process_kill(proc)
	}
@end
}

{
var
	thread_create = $loader.loadprim("std@thread_create", 2),
	thread_current = $loader.loadprim("std@thread_current", 0),
	thread_send = $loader.loadprim("std@thread_send", 2),
	thread_read_message = $loader.loadprim("std@thread_read_message", 1),
	thread_stack = $loader.loadprim("std@thread_stack", 1)

@implementation NL_thread
	+ create:fun param:p {
		return thread_create(fun, p)
	}
	+ current {
		return thread_current()
	}
	+ send:thread message:msg {
		thread_send(thread, msg)
	}
	+ read:block {
		thread_read_message(block)
	}
	+ stack:thread { // do NOT use this on the current thread
		return thread_stack(thread)
	}
@end

var
	lock_create = $loader.loadprim("std@lock_create", 0),
	lock_wait = $loader.loadprim("std@lock_wait", 2),
	lock_release = $loader.loadprim("std@lock_release", 1)

@implementation NL_lock
	+ create {
		return lock_create()
	}
	+ release:lock {
		return lock_release(lock)
	}
	+ wait:lock timeout:time {
		return lock_wait(lock, time)
	}
@end

var
	tls_create = $loader.loadprim("std@tls_create", 0),
	tls_get = $loader.loadprim("std@tls_get", 1),
	tls_set = $loader.loadprim("std@tls_set", 2)

@implementation NL_tls
	+ create {
		return tls_create()
	}
	+ get:tls {
		return tls_get(tls)
	}
	+ set:tls to:val {
		tls_set(tls, val)
	}
@end

var
	mutex_create = $loader.loadprim("std@mutex_create", 0),
	mutex_acquire = $loader.loadprim("std@mutex_acquire", 1),
	mutex_try = $loader.loadprim("std@mutex_try", 1),
	mutex_release = $loader.loadprim("std@mutex_release", 1)

@implementation NL_mutex
	+ create {
		return mutex_create()
	}
	+ acquire:mutex {
		mutex_acquire(mutex)
	}
	+ try:mutex {
		return mutex_try(mutex)
	}
	+ release:mutex {
		mutex_release(mutex)
	}
@end

var
	deque_create = $loader.loadprim("std@deque_create", 0),
	deque_add = $loader.loadprim("std@deque_add", 2),
	deque_push = $loader.loadprim("std@deque_push", 2),
	deque_pop = $loader.loadprim("std@deque_pop", 2)

@implementation NL_deque
	+ create {
		return deque_create()
	}
	+ add:deque message:msg {
		deque_add(deque, msg)
	}
	+ push:deque message:msg {
		deque_push(deque, msg)
	}
	+ pop:deque block:block {
		return deque_pop(deque, block)
	}
@end
}

{
var
	std_serialize = $loader.loadprim("std@serialize", 1),
	std_unserialize = $loader.loadprim("std@unserialize", 2)

@implementation NL_serialize
	+ serialize:obj {
		return std_serialize(obj)
	}
	+ unserialize:str loader:loader {
		return std_unserialize(str, loader)
	}
@end
}

{
var regexp_new = $loader.loadprim("regexp@regexp_new", 1),
	regexp_new_options = $loader.loadprim("regexp@regexp_new_options", 2),
	regexp_match = $loader.loadprim("regexp@regexp_match", 4),
	regexp_replace = $loader.loadprim("regexp@regexp_replace", 3),
	regexp_replace_all = $loader.loadprim("regexp@regexp_replace_all", 3),
	regexp_replace_fun = $loader.loadprim("regexp@regexp_replace_fun", 3),
	regexp_matched = $loader.loadprim("regexp@regexp_matched", 2),
	regexp_matched_pos = $loader.loadprim("regexp@regexp_matched_pos", 2)

@implementation NL_regexp
	+ new:rx {
		return [[this make] init:rx]
	}
	+ new:rx options:options {
		return [[this make] init:rx options:options]
	}
	
	- init:rx {
		this->rx = regexp_new(rx)
		
		return this
	}
	- init:rx options:options {
		this->rx = regexp_new_options(rx, options)
		
		return this
	}
	
	- match:str pos:pos len:len {
		return regexp_match(this->rx, str, pos, len)
	}
	- replace:str1 with:str2 {
		return regexp_replace(this->rx, str1, str2)
	}
	- replace_all:str1 with:str2 {
		return regexp_replace_all(this->rx, str1, str2)
	}
	- replace_fun:str with:func {
		return regexp_replace_fun(this->rx, str, func)
	}
	- matched:n {
		return regexp_matched(this->rx, n)
	}
	- matched_pos:n {
		return regexp_matched_pos(this->rx, n)
	}
@end
}